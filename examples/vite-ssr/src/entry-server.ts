import { renderToString, SSRContext } from "vue/server-renderer"
import { Logger } from "zeed"
import "./main"
import { createApp } from "./main"

const log = Logger("entry-server")

let cache: Record<string, string> = {}

// https://vitejs.dev/guide/ssr.html
// https://github.com/vitejs/vite/tree/main/packages/playground/ssr-vue

export async function render(url: string, manifest: any) {
  log(`render ${url}`)

  let html = cache[url]
  if (!html) {
    log.info(`rendering ${url}`)
    const { app, router, head } = createApp()

    // set the router to the desired URL before rendering
    router.push(url)
    await router.isReady()

    // passing SSR context object which will be available via useSSRContext()
    // @vitejs/plugin-vue injects code into a component's setup() that registers
    // itself on ctx.modules. After the render, ctx.modules would contain all the
    // components that have been instantiated during this render call.
    const ctx: SSRContext = {}
    html = await renderToString(app, ctx)

    if (head) {
      // let dom = new VHTMLDocument()
      // dom.body.innerHTML = html
      // // @ts-ignore
      // head.updateDOM(dom)
      // html = dom.render()
    }

    // for testing. Use deep import built-in module. PR #5248

    // the SSR manifest generated by Vite contains module -> chunk/asset mapping
    // which we can then use to determine what files need to be preloaded for this
    // request.
    // const preloadLinks = renderPreloadLinks(ctx.modules, manifest)
    // log("preloadLinks", preloadLinks)

    // return [html, preloadLinks]
    cache[url] = html
  } else {
    log.info(`take ${url} from cache`, html)
  }

  return html
}

// function renderPreloadLinks(modules: string[], manifest: any) {
//   let links = ""
//   const seen = new Set()
//   log("manifest", manifest)
//   modules.forEach((id) => {
//     const files = manifest[id]
//     if (files) {
//       files.forEach((file: string) => {
//         if (!seen.has(file)) {
//           seen.add(file)
//           links += renderPreloadLink(file)
//         }
//       })
//     }
//   })
//   return links
// }

// function renderPreloadLink(file: string) {
//   if (file.endsWith(".js")) {
//     return `<link rel="modulepreload" crossorigin href="${file}">`
//   } else if (file.endsWith(".css")) {
//     return `<link rel="stylesheet" href="${file}">`
//   } else if (file.endsWith(".woff")) {
//     return ` <link rel="preload" href="${file}" as="font" type="font/woff" crossorigin>`
//   } else if (file.endsWith(".woff2")) {
//     return ` <link rel="preload" href="${file}" as="font" type="font/woff2" crossorigin>`
//   } else if (file.endsWith(".gif")) {
//     return ` <link rel="preload" href="${file}" as="image" type="image/gif">`
//   } else if (file.endsWith(".jpg") || file.endsWith(".jpeg")) {
//     return ` <link rel="preload" href="${file}" as="image" type="image/jpeg">`
//   } else if (file.endsWith(".png")) {
//     return ` <link rel="preload" href="${file}" as="image" type="image/png">`
//   } else {
//     // TODO
//     return ""
//   }
// }
