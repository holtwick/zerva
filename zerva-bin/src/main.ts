/* eslint-disable no-console */
import type { ChildProcess } from 'node:child_process'
import { spawn } from 'node:child_process'
import { chmod } from 'node:fs/promises'
import { normalize } from 'node:path'
import { chmodSync } from 'node:fs'
import type { BuildOptions, Plugin } from 'esbuild'
import { context } from 'esbuild'
import { yamlPlugin } from 'esbuild-plugin-yaml'

// @ts-expect-error xxx
import displayNotification from 'display-notification'
import type { ZervaConf } from './config'

export async function runMain(config: ZervaConf) {
  //
  // Forced exit like CTRL-c
  //

  const keepAlive = setInterval(() => {
    // console.log('Zerva: Keep alive')
  }, 1000)

  let zervaNodeProcess: ChildProcess | undefined
  let zervaNodeProcessDidEndPromise: Promise<number> | undefined
  let zervaNodeProcessDidEndResolve: (value: number) => void | undefined

  // NOTE: although it is tempting, the SIGKILL signal (9) cannot be intercepted and handled
  const signals: any = {
    SIGHUP: 1,
    SIGINT: 2,
    SIGTERM: 15,
  }

  Object.keys(signals).forEach((signal) => {
    process.on(signal, () => {
      // Already in the process of finishing
      if (zervaNodeProcessDidEndPromise)
        return

      console.log(`\n\nZerva: Received a ${signal} signal`)

      stopNode().then(() => {
        // process.exit(128 + (+signals[signal] ?? 0))
        clearInterval(keepAlive)
      }).catch((err) => {
        console.error('Zerva: Exit error', err)
      })
    })
  })

  //
  // Sub process running node
  //

  async function stopNode() {
    if (zervaNodeProcess) {
      zervaNodeProcessDidEndPromise = new Promise(resolve => zervaNodeProcessDidEndResolve = resolve)

      if (config.debug)
        console.log('Zerva: Will stop node process')

      zervaNodeProcess.kill('SIGTERM')
      await zervaNodeProcessDidEndPromise

      if (config.debug)
        console.log('Zerva: Did stop node process\n')
      else
        console.log('Zerva: Stopped app\n')
    }
    zervaNodeProcessDidEndPromise = undefined
    zervaNodeProcessDidEndPromise = undefined
  }

  async function startNode() {
    await stopNode()

    const cwd = process.cwd()
    const nodeArgs = [
      '--enable-source-maps',
      ...config.node,
      config.outfile,
    ]

    if (config.debug)
      console.info(`Zerva: Spawn node in ${cwd} with args:`, nodeArgs)

    zervaNodeProcess = spawn(
      process.execPath,
      nodeArgs,
      {
        cwd,
        stdio: 'inherit',
        env: {
          ...process.env,
          ZERVA_MODE: 'development',
          ZERVA_VERSION: config.version,
        },
      },
    )

    console.info('\nZerva: Starting app')
    zervaNodeProcess.on('error', (err) => {
      console.error('Zerva: Node process error:', err)
    })
    zervaNodeProcess.on('close', (code) => {
      if (config.debug)
        console.info('Zerva: Node process close with code:', code)
      if (zervaNodeProcessDidEndResolve)
        zervaNodeProcessDidEndResolve(code ?? 0)
      zervaNodeProcess = undefined
    })
    // zervaNodeProcess.on('exit', () => {
    //   console.info('Zerva: Node process exit.')
    // })
    // zervaNodeProcess.on('disconnect', () => {
    //   console.info('Zerva: Node process disconnect.')
    // })
  }

  async function notifyError(error: any) {
    try {
      if (!config.build) {
        // https://www.npmjs.com/package/display-notification
        await displayNotification({
          subtitle: 'Zerva Build Error',
          text: error?.text ?? 'Error',
          sound: 'Bottle',
        })
      }
    }
    catch (err) { }
  }

  function toHumanReadableFilePath(path: string) {
    const p = normalize(path)
    const h = process.env.HOME
    if (h && p.startsWith(h))
      return `~${p.slice(h.length)}`

    return p
  }

  console.info(`Zerva: Building from "${toHumanReadableFilePath(config.entry)}"`)

  const plugins = [
    yamlPlugin({}),
  ]

  if (!config.build) {
    plugins.push({
      name: 'zerva-rebuild',
      setup(build) {
        build.onStart(stopNode)
        build.onEnd((result) => {
          if (result.errors?.length > 0) {
            console.log(`build ended with ${result.errors.length} errors`)
            void notifyError(result.errors?.[0])
            return
          }
          try {
            chmodSync(config.outfile, 0o755)
          }
          catch (err) { }
          void startNode()
        })
        build.onDispose(stopNode)
      },
    } as Plugin)
  }

  // Started from command line
  const buildConfig: BuildOptions = {
    bundle: true,
    platform: 'node',
    target: 'node18',
    format: config.esm ? 'esm' : 'cjs',
    entryPoints: [config.entry],
    legalComments: 'none',
    outfile: config.outfile,
    metafile: config.metafile,
    sourcemap: !config.build || config.sourcemap,
    jsxFactory: 'h',
    loader: {
      '.json': 'json',
      ...config.loader,
    },
    plugins,
    banner: {
      js: '/*\n\n    Generated by Zerva <https://github.com/holtwick/zerva>\n\n*/',
    },
    define: {
      // ZERVA_MODE: buildMode ? "production" : "development",
      'ZERVA_DEVELOPMENT': String(!config.build),
      'ZERVA_PRODUCTION': String(config.build),
      'ZERVA_VERSION': `"${config.version}"`,
      'process.env.ZERVA_DEVELOPMENT': String(!config.build),
      'process.env.ZERVA_PRODUCTION': String(config.build),
      'process.env.ZERVA_VERSION': `"${config.version}"`,
      ...config.define,
    } as any,
    minify: config.build,
    external: config.build
      ? ['esbuild', 'fs', 'fsevents', 'notifier', 'node-notifier', ...config.external]
      : ['esbuild', 'fs', 'fsevents', 'notifier', 'node-notifier', 'vite', ...config.external],
    ...config.esbuild,
  }

  if (config.debug)
    console.log('build =', buildConfig)

  // https://github.com/evanw/esbuild/blob/main/CHANGELOG.md#0170
  const buildContext = await context(buildConfig)

  if (!config.build) {
    console.info('Zerva: Watching...')
    await buildContext.watch()
    return
  }

  const result = buildContext.rebuild()
  result
    .then(async (r) => {
      try {
        await chmod(config.outfile, 0o755)
      }
      catch (err) { }

      console.info(`Zerva: Building to "${toHumanReadableFilePath(config.outfile)}" succeeded.`)
      await buildContext.dispose()
    })
    .catch((error: any) => {
      void notifyError(error)
    })
}
